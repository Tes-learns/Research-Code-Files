---
title: "Simulation Study"
author: "Itesiwajuayo Babalola"
date: "2025-10-12"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# All Functions throughout the code
```{r Function1}
### -------------------------------
### Function: generate_mrem_data()
### -------------------------------
# Generates one simulated meta-analysis dataset under a Mixture Random Effects Model (MREM)

generate_mrem_data <- function(K, pi_g, mu_g, tau2_g, s2_min = 0.5, s2_max = 1) {
  
  # ---- Check Inputs ----
  G <- length(pi_g)
  if (abs(sum(pi_g) - 1) > 1e-6) stop("Mixing proportions pi_g must sum to 1.")
  if (length(mu_g) != G | length(tau2_g) != G) stop("Lengths of pi_g, mu_g, and tau2_g must match.")
  
  # ---- Step 1: Generate component membership z_i ----
  z_i <- sample(1:G, size = K, replace = TRUE, prob = pi_g)
  
  # ---- Step 2: Generate true effect sizes Î´*_i ----
  delta_i <- sapply(z_i, function(g) rnorm(1, mean = mu_g[g], sd = sqrt(tau2_g[g])))
  
  # ---- Step 3: Generate within-study variances s_iÂ² ----
  s2_i <- runif(K, min = s2_min, max = s2_max)
  
  # ---- Step 4: Generate observed effect sizes Y_i ----
  Y_i <- rnorm(K, mean = delta_i, sd = sqrt(s2_i))
  
  # ---- Step 5: Return as data frame ----
  data.frame(
    study = 1:K,
    component = z_i,
    delta_true = delta_i,
    s2 = s2_i,
    Y = Y_i
  )
}


```

```{r Function2}
### -------------------------------
### Function: initialize_params()
### -------------------------------
# Generates initial values for each parameter--- to be used in EM algorithm

# Y: observed effect sizes
# s2: vector of within-study variances
# G: number of components (clusters)
# epsilon: small positive constant

initialize_params <- function(Y, s2, G, epsilon = 1e-3) {
  # Step 1: Run k-means clustering
  km <- kmeans(Y, centers = G, nstart = 20)
  
  # Step 2: Component means (ensure numeric vector)
  mu_init <- as.numeric(km$centers)
  
  # Step 3: Cluster assignments
  z_init <- km$cluster
  
  # Step 4: Mixing proportions (ensure numeric vector)
  pi_init <- as.numeric(table(z_init) / length(Y))
  
  # Step 5: Between-study variances (ensure numeric vector)
  tau2_init <- numeric(G)
  for (g in 1:G) {
    Y_g <- Y[z_init == g]
    s2_g <- s2[z_init == g]
    var_Yg <- var(Y_g)
    tau2_init[g] <- max(var_Yg - mean(s2_g), epsilon)
  }
  
  # Step 6: Return as clean numeric list
  list(
    mu_init = mu_init,
    tau2_init = tau2_init,
    pi_init = pi_init
  )
}

```

```{r Funtion3}

### -------------------------------
### Function: update_tau2()
### -------------------------------
# Function to numerically update between study variance parameter estimate--- to be used in EM algorithm

update_tau2 <- function(Y, s2, gam, mu, tau2_init) {
  neg_loglik_tau2_g <- function(tau2_g, Y, s2, gam_g, mu_g) {
    if (tau2_g <= 0) return(1e20)
    v <- tau2_g + s2
    -sum(gam_g * (-0.5 * log(v) - 0.5 * (Y - mu_g)^2 / v))
  }
  
    sapply(seq_along(mu), function(g) {
    optim(
      par = tau2_init[g],
      fn = neg_loglik_tau2_g,
      method = "L-BFGS-B",
      lower = 1e-8,
      Y = Y,
      s2 = s2,
      gam_g = gam[, g],
      mu_g = mu[g]
    )$par
  })
}




```

```{r Function4}

### -------------------------------
### Function: run_em_algorithm()
### -------------------------------
# Function to perform EM algorithm 
# Has a max iteration of 500

run_em_algorithm <- function(Y, s2, mu_init, pi_init, tau2_init, tol = 1e-4, rl = 500) {
  y <- as.vector(Y)
  s2_i <- as.vector(s2)
  mu <- mu_init
  pi <- pi_init
  tau2 <- tau2_init
  g <- length(mu)
  
  loglik_old <- -Inf
  
  for (iter in 1:rl) {
    # E-step
    den_gam <- sapply(1:g, function(j) {
      pi[j] * dnorm(y, mu[j], sqrt(tau2[j] + s2_i))
    })
    gam <- den_gam / rowSums(den_gam)
    
    # M-step
    ng <- colSums(gam)
    npi <- ng / sum(ng)
    
    nmu <- sapply(1:g, function(j) {
      sum(gam[, j] * y / (tau2[j] + s2_i)) /
        sum(gam[, j] / (tau2[j] + s2_i))
    })
    
    ntau2 <- update_tau2(y, s2_i, gam, nmu, tau2)
    
    # Enforce ordering by component mean
    order_idx <- order(nmu)
    nmu <- nmu[order_idx]
    ntau2 <- ntau2[order_idx]
    npi <- npi[order_idx]
    
    # Compute log-likelihood
    loglik <- sum(log(rowSums(sapply(1:g, function(j) {
      npi[j] * dnorm(y, mean = nmu[j], sd = sqrt(ntau2[j] + s2_i))
    }))))
    
    # Convergence check
    if (abs(loglik - loglik_old) < tol && iter > 10) {
      return(list(
        mu = nmu,
        tau2 = ntau2,
        pi = npi,
        loglik = loglik,
        iter = iter,
        converged = TRUE
      ))
    }
    
    mu <- nmu
    tau2 <- ntau2
    pi <- npi
    loglik_old <- loglik
  }
  
  # Return final results even if not converged
  list(
    mu = mu,
    tau2 = tau2,
    pi = pi,
    loglik = loglik,
    iter = rl,
    converged = FALSE
  )
}
```

```{r Function 5}
### -------------------------------
### Function: run_em_simulations()
### -------------------------------
# Incorporates all previously defined functions.
# Repeatedly simulates meta datasets and runs the EM algorithm until 500 converged results are obtained,
# saving parameter estimates, log-likelihoods, convergence status.

run_em_simulations <- function(K, pi_g, mu_g, tau2_g,
                               s2_min = 0.5, s2_max = 1,
                               n_target = 500, rl = 500, tol = 1e-4) {
  
  # Number of components 
  G <- length(pi_g)
  
  # Storage for results
  results <- data.frame()
  n_converged <- 0
  attempt <- 0
  
  while (n_converged < n_target) {
    attempt <- attempt + 1
    
    # Step 1: Generate data
    sim_data <- generate_mrem_data(K = K, pi_g = pi_g, mu_g = mu_g,
                                   tau2_g = tau2_g, s2_min = s2_min, s2_max = s2_max)
    
    # Step 2: Initialize parameters
    init <- initialize_params(sim_data$Y, sim_data$s2, G = G)
    
    # Step 3: Run EM algorithm
    em_res <- run_em_algorithm(
      Y = sim_data$Y,
      s2 = sim_data$s2,
      mu_init = init$mu_init,
      pi_init = init$pi_init,
      tau2_init = init$tau2_init,
      tol = tol,
      rl = rl
    )
    
     # Step 4: Keep only converged results
    if (em_res$converged) {
      n_converged <- n_converged + 1
      
      # Dynamically build a row for results
      res_row <- data.frame(K = K)
      
      # Append mu, tau2, and pi estimates
      for (j in 1:G) {
        res_row[[paste0("mu", j)]]  <- em_res$mu[j]
        res_row[[paste0("tau2", j)]] <- em_res$tau2[j]
        res_row[[paste0("pi", j)]]  <- em_res$pi[j]
      }
      
      # Add log-likelihood, iteration count, and convergence flag
      res_row$loglik <- em_res$loglik
      res_row$iter <- em_res$iter
      res_row$converged <- em_res$converged
      
      results <- rbind(results, res_row)
    }
    
    # Optional progress message
    if (n_converged %% 50 == 0 && n_converged > 0) {
      cat("âœ…", n_converged, "datasets converged after", attempt, "attempts\n")
    }
  }
  
  cat("\nðŸŽ¯ Finished! Collected", n_converged, "converged results after", attempt, "attempts.\n")
  return(results)
}

```

```{r Function 6}
### -------------------------------
### Function: compute_bias_mse()
### -------------------------------
# Calculates the bias and mean squared error (MSE) for each model parameter across converged simulations,
# comparing estimated parameters to their known true values.
compute_bias_mse <- function(results, mu_true, tau2_true, pi_true) {
  # Ensure only converged results are used
  res <- subset(results, converged == TRUE)
  
  # Determine number of components (G)
  G <- length(mu_true)
  
  # Build true value list dynamically
  true_vals <- c(
    setNames(mu_true, paste0("mu", 1:G)),
    setNames(tau2_true, paste0("tau2", 1:G)),
    setNames(pi_true, paste0("pi", 1:G))
  )
  
  # Parameters to assess
  params <- names(true_vals)
  
  # Compute Bias and MSE for each parameter
  summary_df <- data.frame(
    Parameter = params,
    True = unlist(true_vals),
    Bias = sapply(params, function(p) mean(res[[p]] - true_vals[[p]], na.rm = TRUE)),
    RMSE  = sapply(params, function(p) sqrt(mean((res[[p]] - true_vals[[p]])^2, na.rm = TRUE)))
  )
  
  return(summary_df)
}


```

```{r Function 7 and 8}
library(ggplot2)

### -------------------------------
### Function: mix_density()
### -------------------------------
# Computes the probability density of a finite mixture of normal 
# distributions at a set of given points. For each value of y
# the function sums the weighted component densities using the specified 
# mixture weights (pi), means (mu), and variances (tau^2).

mix_density <- function(y, mu, tau2, pi) {
  sapply(y, function(x) sum(pi * dnorm(x, mean = mu, sd = sqrt(tau2))))
}


### -------------------------------
### Function: plot_mixture_fit()
### -------------------------------
# Plots the true and estimated mixture densities of the random effects to visually
# assess how well the EM algorithm recovered the underlying distribution.
# The function selects the simulation with the highest log-likelihood,
# computes both densities over a common range, and overlays them 
# on a single plot for visual comparison.
# Additionally, it overlays the *estimated* component densities
# (scaled by their estimated mixing proportions) in black to show
# how the estimated components contribute to the total fit.

plot_mixture_fit <- function(res_data, mu_true, tau2_true, pi_true, scenario_name) {
  # 1ï¸âƒ£ Find the best (highest log-likelihood) dataset
  best_index <- which.max(res_data$loglik)
  est_params <- res_data[best_index, ]
  
  # 2ï¸âƒ£ Extract estimated parameters dynamically
  G <- length(mu_true)
  mu_hat   <- as.numeric(est_params[paste0("mu", 1:G)])
  tau2_hat <- as.numeric(est_params[paste0("tau2", 1:G)])
  pi_hat   <- as.numeric(est_params[paste0("pi", 1:G)])
  
  # 3ï¸âƒ£ Compute mixture densities
  y_seq <- seq(min(mu_true) - 3 * sqrt(max(tau2_true)),
               max(mu_true) + 3 * sqrt(max(tau2_true)),
               length.out = 1000)
  
  true_density <- mix_density(y_seq, mu_true, tau2_true, pi_true)
  est_density  <- mix_density(y_seq, mu_hat, tau2_hat, pi_hat)
  
  # 4ï¸âƒ£ Compute individual *estimated* component densities
  comp_densities_hat <- sapply(1:G, function(g)
    pi_hat[g] * dnorm(y_seq, mean = mu_hat[g], sd = sqrt(tau2_hat[g]))
  )
  df_comp <- data.frame(
    y = rep(y_seq, G),
    density = as.vector(comp_densities_hat),
    component = factor(rep(1:G, each = length(y_seq)))
  )
  
  # 5ï¸âƒ£ Main data for overlaying densities
  df_plot <- data.frame(
    y = y_seq,
    True = true_density,
    Estimated = est_density
  )
  
  # 6ï¸âƒ£ Plot (publication-style)
  ggplot(df_plot, aes(x = y)) +
    geom_line(aes(y = True, colour = "True"), linewidth = 0.8) +
    geom_line(aes(y = Estimated, colour = "Estimated"),
              linetype = "dashed", linewidth = 0.8) +
    geom_line(data = df_comp, aes(y = density, group = component),
              colour = "black", linetype = "dotdash", linewidth = 0.5) +
    scale_colour_manual(values = c("True" = "blue", "Estimated" = "red")) +
    labs(x = "Random Effect", y = "Density", colour = "") +
    theme_minimal(base_size = 14) +
    theme(
      plot.title = element_blank(),
      plot.subtitle = element_blank(),
      legend.position = "top",
      legend.title = element_blank(),
      axis.title = element_text(size = 13),
      axis.text = element_text(size = 12)
    )
}


```
NB: For logical flow in dissertation, scenario numbering differs from the ones used in code
| Scenario in paper | Scenario in code    |
|:------------------|:-------------------:| 
|1                  | 4                   | 
|2                  | 2                   |
|3                  | 1                   | 
|4                  | 3                   |

# Scenario 1

## Scenario 1: K = 150


```{r Scenario 1 K150}
### -------------------------------
### Scenario 1
### -------------------------------

set.seed(315)
 
# Scenario: 3-component mixture
mu_g <- c(-2.5, -1, 2.5)
tau2_g <- c(0.7^2, 0.7^2, 0.6^2)
pi_g <- c(0.2, 0.4, 0.4)

res_K150 <- run_em_simulations(K = 150, pi_g = pi_g, mu_g = mu_g, tau2_g = tau2_g)

summary_K150 <- compute_bias_mse(
 results = res_K150,
 mu_true = mu_g,
 tau2_true = tau2_g,
 pi_true = pi_g
)

summary_K150

```

## Scenario 1: K= 500



```{r scenario 1 K500}

set.seed(315)

res_K500 <- run_em_simulations(K = 500, pi_g = pi_g, mu_g = mu_g, tau2_g = tau2_g)

# summary_K500 <- compute_bias_mse(
#   results = res_K500,
#   mu_true = mu_g,
#   tau2_true = tau2_g,
#   pi_true = pi_g
# )
# 
# summary_K500
```

## Scenario 1: K= 1000



```{r Scenario 1 K1000}

set.seed(315)

res_K1000 <- run_em_simulations(K = 1000, pi_g = pi_g, mu_g = mu_g, tau2_g = tau2_g)

summary_K1000 <- compute_bias_mse(
  results = res_K1000,
  mu_true = mu_g,
  tau2_true = tau2_g,
  pi_true = pi_g
)

summary_K1000

```

## Scenario 1: K= 1500

```{r Scenario 1 K1500}

set.seed(315)

res_K1500 <- run_em_simulations(K = 1500, pi_g = pi_g, mu_g = mu_g, tau2_g = tau2_g)

summary_K1500 <- compute_bias_mse(
  results = res_K1500,
  mu_true = mu_g,
  tau2_true = tau2_g,
  pi_true = pi_g
)

summary_K1500

# Scenario 1
plot_mixture_fit(
  res_data = res_K1500,
  mu_true = c(-2.5, -1, 2.5),
  tau2_true = c(0.7^2, 0.7^2, 0.6^2),
  pi_true = c(0.2, 0.4, 0.4),
  scenario_name = "Scenario 1: 3-Component Mixture"
)

```

# Scenario 2

## Scenario 2: K = 150

```{r Scenario 2 K150}
### -------------------------------
### Scenario 2
### -------------------------------

set.seed(1855)

# Scenario: 2-component mixture - Asymmetric heterogeneity
pi_g <- c(0.56, 0.44)
mu_g <- c(-0.5, 1)
tau2_g <- c(0.6^2, 0.4^2)

s2.res_K150 <- run_em_simulations(K = 150, pi_g = pi_g, mu_g = mu_g, tau2_g = tau2_g)

s2.summary_K150 <- compute_bias_mse(
  results = s2.res_K150,
  mu_true = mu_g,
  tau2_true = tau2_g,
  pi_true = pi_g
)

s2.summary_K150

```

## Scenario 2: K= 500



```{r Scenario 2 K500}

set.seed(1855)

s2.res_K500 <- run_em_simulations(K = 500, pi_g = pi_g, mu_g = mu_g, tau2_g = tau2_g)

s2.summary_K500 <- compute_bias_mse(
  results = s2.res_K500,
  mu_true = mu_g,
  tau2_true = tau2_g,
  pi_true = pi_g
)

s2.summary_K500
```

## Scenario 2: K= 1000



```{r Scenario 2 K1000}

set.seed(1855)

s2.res_K1000 <- run_em_simulations(K = 1000, pi_g = pi_g, mu_g = mu_g, tau2_g = tau2_g)

s2.summary_K1000 <- compute_bias_mse(
  results = s2.res_K1000,
  mu_true = mu_g,
  tau2_true = tau2_g,
  pi_true = pi_g
)

s2.summary_K1000

```

## Scenario 2: K= 1500



```{r Scenario 2 K1500}

set.seed(1855)

s2.res_K1500 <- run_em_simulations(K = 1500, pi_g = pi_g, mu_g = mu_g, tau2_g = tau2_g)

s2.summary_K1500 <- compute_bias_mse(
  results = s2.res_K1500,
  mu_true = mu_g,
  tau2_true = tau2_g,
  pi_true = pi_g
)

s2.summary_K1500

# Scenario 2
plot_mixture_fit(
  res_data = s2.res_K1500,
  mu_true = c(-0.5, 1),
  tau2_true = c(0.6^2, 0.4^2),
  pi_true = c(0.56, 0.44),
  scenario_name = "Scenario 2: 2-Component, Mild Heterogeneity"
)


```

# Scenario 3

## Scenario 3: K = 150
```{r Scenario 3 K150}
### -------------------------------
### Scenario 3
### -------------------------------

set.seed(315)

# Scenario: 2-component mixture - high heterogeneity
pi_g <- c(0.33, 0.67)
mu_g <- c(-1, 1)
tau2_g <- c(1.5^2, 1.2^2)

s3.res_K150 <- run_em_simulations(K = 150, pi_g = pi_g, mu_g = mu_g, tau2_g = tau2_g)

s3.summary_K150 <- compute_bias_mse(
  results = s3.res_K150,
  mu_true = mu_g,
  tau2_true = tau2_g,
  pi_true = pi_g
)

s3.summary_K150

```

## Scenario 3: K= 500

```{r Scenario 3 K500}

set.seed(315)

s3.res_K500 <- run_em_simulations(K = 500, pi_g = pi_g, mu_g = mu_g, tau2_g = tau2_g)

s3.summary_K500 <- compute_bias_mse(
  results = s3.res_K500,
  mu_true = mu_g,
  tau2_true = tau2_g,
  pi_true = pi_g
)

s3.summary_K500
```

## Scenario 3: K= 1000

```{r Scenario 3 K1000}

set.seed(315)

s3.res_K1000 <- run_em_simulations(K = 1000, pi_g = pi_g, mu_g = mu_g, tau2_g = tau2_g)

s3.summary_K1000 <- compute_bias_mse(
  results = s3.res_K1000,
  mu_true = mu_g,
  tau2_true = tau2_g,
  pi_true = pi_g
)

s3.summary_K1000

```

## Scenario 3: K= 1500

```{r Scenario 3 K1500}

set.seed(315)

s3.res_K1500 <- run_em_simulations(K = 1500, pi_g = pi_g, mu_g = mu_g, tau2_g = tau2_g)

s3.summary_K1500 <- compute_bias_mse(
  results = s3.res_K1500,
  mu_true = mu_g,
  tau2_true = tau2_g,
  pi_true = pi_g
)

s3.summary_K1500

# Scenario 3
plot_mixture_fit(
  res_data = s3.res_K1500,
  mu_true = c(-1, 1),
  tau2_true = c(1.5^2, 1.2^2),
  pi_true = c(0.33, 0.67),
  scenario_name = "Scenario 3: 2-Component, High Heterogeneity"
)

```

# Scenario 4

## Scenario 4: K = 150
```{r Scenario 4 K150}
### -------------------------------
### Scenario 4
### -------------------------------

set.seed(315)

# Scenario 4: No mixture
pi_g <- c(1)
mu_g <- c(0.5)
tau2_g <- c(0.8^2)

s4.res_K150 <- run_em_simulations(K = 150, pi_g = pi_g, mu_g = mu_g, tau2_g = tau2_g)

s4.summary_K150 <- compute_bias_mse(
  results = s4.res_K150,
  mu_true = mu_g,
  tau2_true = tau2_g,
  pi_true = pi_g
)

s4.summary_K150



```

## Scenario 4: K= 500

```{r Scenario 4 K500}

set.seed(315)

s4.res_K500 <- run_em_simulations(K = 500, pi_g = pi_g, mu_g = mu_g, tau2_g = tau2_g)

s4.summary_K500 <- compute_bias_mse(
  results = s4.res_K500,
  mu_true = mu_g,
  tau2_true = tau2_g,
  pi_true = pi_g
)

s4.summary_K500
```

## Scenario 4: K= 1000

```{r Scenario 4 K1000}

set.seed(315)

s4.res_K1000 <- run_em_simulations(K = 1000, pi_g = pi_g, mu_g = mu_g, tau2_g = tau2_g)

s4.summary_K1000 <- compute_bias_mse(
  results = s4.res_K1000,
  mu_true = mu_g,
  tau2_true = tau2_g,
  pi_true = pi_g
)

s4.summary_K1000

```

## Scenario 4: K= 1500

```{r Scenario 4 K1500}

set.seed(315)

s4.res_K1500 <- run_em_simulations(K = 1500, pi_g = pi_g, mu_g = mu_g, tau2_g = tau2_g)

s4.summary_K1500 <- compute_bias_mse(
  results = s4.res_K1500,
  mu_true = mu_g,
  tau2_true = tau2_g,
  pi_true = pi_g
)

s4.summary_K1500

# Scenario 4
plot_mixture_fit(
  res_data = s4.res_K1500,
  mu_true = c(0.5),
  tau2_true = c(0.8^2),
  pi_true = c(1),
  scenario_name = "Scenario 4: Single Component (No Mixture)"
)

```

